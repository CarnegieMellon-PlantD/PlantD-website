# Business Analysis

## Overview
![Diagram shows a flowchart.  Several experiments point to Digital Twin.  Traffic Model points to Traffic Pattern.  Traffic Patterna and Digital Twin point to Simulation, the final box in the chart. Explanations within each box match explanations in the text below this diagram](ba_workflow.png)

If you have run one or more experiments on a pipeline, 
you can now extrapolate from those experiments to assess
the business implications of using the pipeline.

This set of PlantD resources lets you lay out a prediction
of what inbound traffic will look like for a year of
operation, with its seasonal or daily highs and lows,
and estimate the total cost, overall performance, and 
how often your pipeline is likely to violate service
level objectives (e.g. "data must be processed within 
10 seconds, 99.9% of the time during the year").

## Experiment

To run an analysis, you should start by conducting [Experiments](experiment.md).
In principle, many experiments with different mixes of
dataset contents and load patterns can expose a variety of pipeline behaviors,
which the Digital Twin can use to construct an accurate model.

## Digital Twin

The digital twin summarizes a set of experiments, mathematically, to 
describe the likely cost, latency, and throughput of a pipeline given a 
fluctuating load level.  

Note that the digital twin CANNOT process a real dataset, just a
time series describing the SIZE of a dataset.  If your pipeline behaves
differently depending on the content of the data, the digital twin
cannot capture that.

As an open source project, you can of course create more sophisticated
analyses of experiments to produce more advanced twins; but out of
the box we provide the following kinds of twin:

- *simple* analyzes the first experiment in the list, assumes that the
load pattern exceeds the pipeline's throughput capabilities, and thus
uses the maximum throughput as the pipeline's peak.  The model it builds
assumes the pipeline cannot scale beyond this, but has an infinite queue
to handle load faster than that throughput.  It assumes cost does not
depend on the load, just on the length of time the pipeline is running.

- *quickscaling* uses the *simple* model as a base, but assumes an
optimal horizontal scaling algorithm.  Thus latency is never affected
by queuing, but cost is proportional to the number of instances necessary
to handle any given amount of load.

## Traffic Model

The traffic model is a set of parameters abstractly describing the load
a pipeline will face over some projected future year.  There is currently
no GUI to create this model; you must download a JSON file, edit or replace it
manually or using your own scripts, then upload a replacement.

The parameters are as follows:
- `start_row_cnt`: The average number of records per second received at the
start of the year, ignoring daily and monthly variations
- `yearly_growth_rate`: By what factor is traffic expected to grow or shrink
over the course of the year?  For example 1.0 means no overall change despite
monthly and weekly variation; 0.5 would mean an overall shrinkage of data
ingestion by 50%.
- `model_name`: You can safely ignore this; it can be used to represent the 
provenance of your data; however this is
not the name used by PlantD; it's for your own documentation purposes.  The name
used by PlantD is specified in the user interface.
- `corrections_monthly`: For each month of the year, a correction factor
reflecting how much higher or lower traffic will be that month compared to
the average.  1.0 means a typical month; 1.5 means 50% more traffic than
usual.  These twelve numbers should average to 1.0.  The format of this
array is a json record, with fields:
   - `data`: a comma-separated list of 12 values
   - `index`: a comma-separated list of the numbers from 1 to 12, representing corresponding months
   - `index_name`: the name of this index, `Month`
   - `name`: the name of this data series, `row_cnt_seasonal_correction`
- `corrections_hourly`: For each hour of a week, a similar correction factor
reflecting how much higher or lower traffic will be at that hour of the
typical week.  The format of this array is a json record, with fields:
   - `data`: a comma-separated list of 168 values (i.e. 24 hours x 7 days)
   - `index`: a comma-separated list of lists of day-hour pairs:  `[["FRI", 0], ["FRI", 1], ["FRI", 2],...`
        the order doesn't matter as long as they align with the data 
   - `index_names`: a list containing the names of the two indexes, `["DOW", "Hour"]`
   
## Traffic Pattern

This is an internal object not visible to the user -- it is an hour by hour prediction of 
input load, generated by working out the implications of the Traffic Model.

## Simulation

In the user interface, each simulation represents a different pairing of a digital twin with a 
traffic model.  We believe it will be useful to create "minimal pairs" of simulations, which
differ either by traffic model (to do a risk analysis of a pipeline, showing how it will perform
under optimistic and pessimistic predictions about traffic growth); or by pipeline (as a way of
comparing how two variants of a pipeline will perform under a given business assumption).

The latter comparison might be useful to show progress in a pipeline under development, showing
the same experiment under an original and improved implementation of a pipeline, for estimating
the projected cost savings of some improvement.

The output of the simulation indicates the digital twin's prediction of
cost, latency, throughput if presented with a traffic pattern.

